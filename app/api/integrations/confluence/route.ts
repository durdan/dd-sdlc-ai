import { type NextRequest, NextResponse } from "next/server"

export async function POST(req: NextRequest) {
  try {
    const { 
      config, 
      projectData, 
      documents,
      projectName,
      description 
    } = await req.json()

    console.log('üìö Confluence Integration Request:', { 
      hasConfig: !!config, 
      projectName, 
      hasDocuments: !!documents 
    })

    // Validate Confluence configuration
    if (!config?.confluenceUrl || !config?.confluenceSpace || !config?.confluenceEmail || !config?.confluenceToken) {
      console.error('‚ùå Missing Confluence configuration')
      return NextResponse.json({ 
        success: false, 
        error: 'Missing Confluence configuration (URL, Space Key, Email, or API Token)' 
      }, { status: 400 })
    }

    const confluenceBase = config.confluenceUrl.replace(/\/$/, '')
    const auth = Buffer.from(`${config.confluenceEmail}:${config.confluenceToken}`).toString('base64')
    
    console.log('üîß Confluence Config:', { 
      url: confluenceBase, 
      space: config.confluenceSpace, 
      email: config.confluenceEmail 
    })

    const createdPages = []

    // Helper function to convert markdown to Confluence storage format
    const convertToConfluenceMarkup = (content: string): string => {
      if (!content) return ''
      
      return content
        // Convert markdown headers to Confluence headers
        .replace(/^### (.*$)/gm, '<h3>$1</h3>')
        .replace(/^## (.*$)/gm, '<h2>$1</h2>')
        .replace(/^# (.*$)/gm, '<h1>$1</h1>')
        // Convert markdown bold to Confluence bold
        .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
        // Convert markdown italic to Confluence italic
        .replace(/\*(.*?)\*/g, '<em>$1</em>')
        // Convert markdown code blocks to Confluence code blocks
        .replace(/```([\s\S]*?)```/g, '<ac:structured-macro ac:name="code"><ac:plain-text-body><![CDATA[$1]]></ac:plain-text-body></ac:structured-macro>')
        // Convert markdown inline code to Confluence monospace
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        // Convert markdown lists to Confluence lists
        .replace(/^\* (.*$)/gm, '<li>$1</li>')
        .replace(/^- (.*$)/gm, '<li>$1</li>')
        // Wrap list items in ul tags
        .replace(/((<li>.*<\/li>\s*)+)/g, '<ul>$1</ul>')
        // Convert numbered lists
        .replace(/^\d+\. (.*$)/gm, '<li>$1</li>')
        // Clean up paragraphs
        .replace(/\n\s*\n/g, '</p><p>')
        .replace(/^(?!<h|<p|<ul|<ol|<li|<ac:)(.+)$/gm, '<p>$1</p>')
        .trim()
    }

    // Helper function to convert Mermaid diagrams to Confluence format
    const convertMermaidToConfluence = (mermaidContent: string): string => {
      if (!mermaidContent) return ''
      
      // Extract individual Mermaid diagrams
      const diagrams = mermaidContent.split('```mermaid').filter(d => d.trim())
      let confluenceContent = ''
      
      diagrams.forEach((diagram, index) => {
        const cleanDiagram = diagram.replace(/```/g, '').trim()
        if (cleanDiagram) {
          confluenceContent += `
            <h3>Diagram ${index + 1}</h3>
            <ac:structured-macro ac:name="code">
              <ac:parameter ac:name="language">mermaid</ac:parameter>
              <ac:plain-text-body><![CDATA[${cleanDiagram}]]></ac:plain-text-body>
            </ac:structured-macro>
            <p><em>Note: This Mermaid diagram can be rendered using Confluence Mermaid plugins or external tools.</em></p>
          `
        }
      })
      
      return confluenceContent
    }

    try {
      // Create Business Requirements as the main parent page
      console.log('üìÑ Creating Business Requirements parent page...')
      
      const businessContent = documents?.businessAnalysis ? convertToConfluenceMarkup(documents.businessAnalysis) : '<p>Business analysis content not available.</p>'
      
      const parentPagePayload = {
        type: "page",
        title: `${projectName} - Business Requirements & Analysis`,
        space: { key: config.confluenceSpace },
        body: {
          storage: {
            value: `
              <h1>Business Requirements & Analysis</h1>
              <h2>Project: ${projectName}</h2>
              <p><strong>Project Description:</strong> ${description || 'Auto-generated by SDLC Automation Platform'}</p>
              <p><em>Generated on: ${new Date().toLocaleDateString()}</em></p>
              
              <ac:structured-macro ac:name="info">
                <ac:rich-text-body>
                  <p>This is the main business requirements document for ${projectName}. All other SDLC documentation is organized as child pages under this document.</p>
                </ac:rich-text-body>
              </ac:structured-macro>
              
              <h2>Child Documentation Pages</h2>
              <ac:structured-macro ac:name="children">
                <ac:parameter ac:name="all">true</ac:parameter>
                <ac:parameter ac:name="sort">creation</ac:parameter>
              </ac:structured-macro>
              
              <hr/>
              <h2>Business Analysis Content</h2>
              ${businessContent}
              
              <hr/>
              <p><em>This documentation was automatically generated by the SDLC Automation Platform.</em></p>
            `,
            representation: "storage"
          }
        }
      }

      const parentResponse = await fetch(`${confluenceBase}/rest/api/content`, {
        method: 'POST',
        headers: {
          'Authorization': `Basic ${auth}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(parentPagePayload)
      })

      if (!parentResponse.ok) {
        const errorText = await parentResponse.text()
        console.error('‚ùå Parent page creation failed:', errorText)
        throw new Error(`Parent page creation failed: ${errorText}`)
      }

      const parentPage = await parentResponse.json()
      console.log('‚úÖ Parent page created:', parentPage.title)
      createdPages.push({
        type: 'Parent Page',
        title: parentPage.title,
        url: `${confluenceBase}/pages/viewpage.action?pageId=${parentPage.id}`,
        id: parentPage.id
      })

      // Create child pages for each SDLC document (excluding Business Analysis since it's in parent)
      const documentTypes = [
        { 
          doc: 'functionalSpec', 
          title: 'Functional Specification', 
          description: 'Feature specifications and user stories',
          icon: 'üìã'
        },
        { 
          doc: 'technicalSpec', 
          title: 'Technical Specification', 
          description: 'Architecture and technical implementation details',
          icon: '‚öôÔ∏è'
        },
        { 
          doc: 'uxSpec', 
          title: 'UX/UI Specification', 
          description: 'User experience and interface design',
          icon: 'üé®'
        }
      ]

      for (const docType of documentTypes) {
        if (documents && documents[docType.doc]) {
          console.log(`üìÑ Creating child page for ${docType.title}...`)
          
          const documentContent = convertToConfluenceMarkup(documents[docType.doc])

          const childPagePayload = {
            type: "page",
            title: `${docType.icon} ${docType.title} - ${projectName}`,
            space: { key: config.confluenceSpace },
            ancestors: [{ id: parentPage.id }],
            body: {
              storage: {
                value: `
                  <h1>${docType.icon} ${docType.title}</h1>
                  <p><strong>Project:</strong> ${projectName}</p>
                  <p><strong>Description:</strong> ${docType.description}</p>
                  <p><em>Generated on: ${new Date().toLocaleDateString()}</em></p>
                  
                  <ac:structured-macro ac:name="note">
                    <ac:rich-text-body>
                      <p>This document is part of the SDLC documentation for ${projectName}. 
                      <ac:link><ri:page ri:content-title="${parentPage.title}"/><ac:plain-text-link-body>Return to Business Requirements</ac:plain-text-link-body></ac:link></p>
                    </ac:rich-text-body>
                  </ac:structured-macro>
                  
                  <hr/>
                  <h2>Document Content</h2>
                  ${documentContent}
                  
                  <hr/>
                  <p><em>This documentation was automatically generated by the SDLC Automation Platform.</em></p>
                `,
                representation: "storage"
              }
            }
          }

          const childResponse = await fetch(`${confluenceBase}/rest/api/content`, {
            method: 'POST',
            headers: {
              'Authorization': `Basic ${auth}`,
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(childPagePayload)
          })

          if (childResponse.ok) {
            const childPage = await childResponse.json()
            console.log(`‚úÖ Child page created: ${childPage.title}`)
            createdPages.push({
              type: 'Documentation Page',
              title: childPage.title,
              url: `${confluenceBase}/pages/viewpage.action?pageId=${childPage.id}`,
              id: childPage.id
            })
          } else {
            const errorText = await childResponse.text()
            console.error(`‚ùå Child page creation failed for ${docType.title}:`, errorText)
          }
        }
      }

      // Create Mermaid Diagrams page if diagrams exist
      if (documents && documents.mermaidDiagrams) {
        console.log('üìä Creating Mermaid Diagrams page...')
        
        const mermaidContent = convertMermaidToConfluence(documents.mermaidDiagrams)
        
        const mermaidPagePayload = {
          type: "page",
          title: `üìä System Diagrams - ${projectName}`,
          space: { key: config.confluenceSpace },
          ancestors: [{ id: parentPage.id }],
          body: {
            storage: {
              value: `
                <h1>üìä System Diagrams</h1>
                <p><strong>Project:</strong> ${projectName}</p>
                <p><strong>Description:</strong> Architecture and flow diagrams for the system</p>
                <p><em>Generated on: ${new Date().toLocaleDateString()}</em></p>
                
                <ac:structured-macro ac:name="note">
                  <ac:rich-text-body>
                    <p>This document contains Mermaid diagrams for ${projectName}. 
                    <ac:link><ri:page ri:content-title="${parentPage.title}"/><ac:plain-text-link-body>Return to Business Requirements</ac:plain-text-link-body></ac:link></p>
                  </ac:rich-text-body>
                </ac:structured-macro>
                
                <ac:structured-macro ac:name="info">
                  <ac:rich-text-body>
                    <p><strong>Rendering Mermaid Diagrams:</strong></p>
                    <ul>
                      <li>Install a Confluence Mermaid plugin (e.g., "Mermaid for Confluence" or "Draw.io Diagrams")</li>
                      <li>Or copy the diagram code to external Mermaid tools like <a href="https://mermaid.live">mermaid.live</a></li>
                      <li>The diagrams below are provided in Mermaid syntax format</li>
                    </ul>
                  </ac:rich-text-body>
                </ac:structured-macro>
                
                <hr/>
                <h2>System Diagrams</h2>
                ${mermaidContent || '<p>No Mermaid diagrams available for this project.</p>'}
                
                <hr/>
                <p><em>This documentation was automatically generated by the SDLC Automation Platform.</em></p>
              `,
              representation: "storage"
            }
          }
        }

        const mermaidResponse = await fetch(`${confluenceBase}/rest/api/content`, {
          method: 'POST',
          headers: {
            'Authorization': `Basic ${auth}`,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(mermaidPagePayload)
        })

        if (mermaidResponse.ok) {
          const mermaidPage = await mermaidResponse.json()
          console.log(`‚úÖ Mermaid Diagrams page created: ${mermaidPage.title}`)
          createdPages.push({
            type: 'Diagrams Page',
            title: mermaidPage.title,
            url: `${confluenceBase}/pages/viewpage.action?pageId=${mermaidPage.id}`,
            id: mermaidPage.id
          })
        } else {
          const errorText = await mermaidResponse.text()
          console.error(`‚ùå Mermaid Diagrams page creation failed:`, errorText)
        }
      }

    } catch (error) {
      console.error('‚ùå Confluence page creation error:', error)
      return NextResponse.json({ 
        success: false, 
        error: `Confluence integration failed: ${error.message}` 
      }, { status: 500 })
    }

    console.log('üéâ Confluence integration completed:', createdPages)

    return NextResponse.json({
      success: true,
      message: `Successfully created ${createdPages.length} Confluence pages`,
      pages: createdPages,
      confluenceSpaceUrl: `${confluenceBase}/spaces/${config.confluenceSpace}`
    })

  } catch (error) {
    console.error('‚ùå Confluence integration error:', error)
    return NextResponse.json({ 
      success: false, 
      error: error.message || 'Unknown error occurred' 
    }, { status: 500 })
  }
}
